Modularité PDM avec Sencha Cmd
==


## Introduction
Le but de cette étude est de déterminer si cet outil répond aux besoins Lectra pour le packaging et l'integration de modules PDM développé avec ExtJs dans une application Web Lectra.
Il s'agit de faciliter l'utilisation et la distibution de chaque module en supprimant la gestion des "stacks", beaucoup trop contraignante au sein du PDM.
La mise en oeuvre de Sencha au travers de ses commandes en ligne va être évaluée, ainsi que la rapidité avec laquelle un module peut être packagé et intégré dans une application.

## Mise en oeuvre
Sencha Cmd est un outil multi-plateforme en ligne de commande, qui fournit les tâches automatisées concernant le cycle de vie complet d'une applications en partant de la génération d'un nouveau projet de déploiement, jusqu'à l'obtention d'une version de production. Nous avons utilisé principalemnt les commandes de generation de workspace, de packaging de module et de build d'une l'application. L'application générée ainsi est minimaliste, un simple panel avec onglets. Pour les besoins de notre test, nous modifions l'application pour intégrer un container "Card Infos"
en provenance d'un package, et présentant une "vue" sur la BOM d'un produit. Un bouton est prévu pour simuler l'interaction avec l'utilisateur et déclencher le chargement du Card via une API Rest et un jBoss en local sur un poste de développeur. L'évaluation va être faite à la fois pour Ext5 et Ext6.

## Réalisation
### Installation de Sencha
Un installeur, qui peut fonctionner en mode silencieux, déploie Sencha sur le poste. Un pré requis impose l'installation de Ruby auparavant.

### Generation du Workspace de l'application
Un Workspace est un dossier qui contient une ou plusieurs pages Web, frameworks, packages et autres codes ou fichiers partagés.
L'emplacement du dossier racine du Workspace doit être choisie pour faciliter les besoins ainsi que les exigences en matière de contrôle de source.
La commande associée pour cela est:

	sencha -sdk <path to extjs sdk> generate workspace /path/to/workspace

Exemple :

	sencha -sdk c:\apps\extjs_sdk generate workspace c:\apps\MyApp

On obtient alors l'arborescence suivante :

	MyApp/                 // root folder
	   sencha/             // Sencha-specific files (e.g. configuration)
	      workspace/       // Workspace-specific content (see below)
	         sencha.cfg    // Configuration file for Sencha Cmd
	         plugin.xml    // Plugin for Sencha Cmd
	   ext                 // extjs sdk copied from c:\apps\extjs_sdk


### Packaging du module CardInfos
Le Workspace existe, il va pouvoir héberger à présent des packages. Pour générer un Package, on se postionne sous le Workspace et on utilise la commande suivante :

	sencha generate package cardInfos

On obtient alors l'arborescence suivante :

	MyApp/
	   packages/
	      cardInfos/              // Top-level folder for the package
	         .sencha/
	            sencha.cfg        // Sencha Cmd configuration for this package
	            build-impl.xml    // Generated build script for package
	            plugin.xml        // Sencha Cmd plugin for this package
	            codegen.json      // Data to support 3-way merge in code generator
	         docs/                // Documentation for the package
	         screenshots/         // Screen shots for Sencha Market
	         licenses/            // License agreement
	         overrides/           // Folder for automatically activated overrides
	         resources/           // Static resources (typically has images folder)
	         sass/                // Container for Sass code
	            etc/              // General, non-component oriented Sass
	            src/              // Sass rules and mixins named by component
	            var/              // Sass variables named by component
	         src/                 // Folder for normal JavaScript code
	         build.xml            // Build script (called by `sencha package build`)
	         package.json         // Package descriptor
	         Readme.md            // High-level information about this package

Deux fichiers de paramétrages sont necessaires pour chaque Package.
En premier "package.json" qui contient une description du package comme suit :

	{
	    "name": "cardInfos",
	    "type": "code",
	    "creator": "anonymous",
	    "summary": "Short summary",
	    "detailedDescription": "Long description of package",
	    "version": "1.0.0",
	    "compatVersion": "1.0.0",
	    "format": "1",
	    "slicer": {
	        "js": [
	            {
	                "path": "${package.dir}/sass/example/custom.js",
	                "isWidgetManifest": true
	            }
	        ]
	    },
	    "output": "${package.dir}/build",
	    "local": true,
	    "requires": [
		]
	}

L'élément "requires" permet d'indiquer que le package référence des appels à un ou plusieurs autres package. Il en va de même pour l'application qui doit listé la totalité des packages utilisés.

En second ".sencha/package/sencha.cfg" qui est utilisé par les commandes de build et de packaging.
A partir du moment où le Package existe on peut y joindre notre code. Le code de CarInfos sur le Trunk (WebClient_Card) fut ainsi transféré dans ce Package sous /src.
A présent on peut builder avec la commande :

	sencha package build

Le résultat du build indique que les methodes ExtJs ne sont pas reconnues. Il faut penser à modifier le fichier de config du Package "sencha.cfg" et y ajouter la ligne :

	package.framework=ext

Ainsi durant le build du Package, Sencha localise la distrib de Ext, et le build abouti sans erreur. Au final deux fichiers js sont générés (cardinfos.js minifié et carInfos-debug.js)sous le repertoire build, ainsi qu'un fickier .pkg sous le répertoire build de l'application (utilisé par le processus de l'application). Pour le module CardInfos, ce processus de Packaging sous Sencha a posé trés peu de problémes.

### Packaging du module PdmCommon
Le module CardInfos va avoir besoin du module PdmCommon pour être intégré au sein de l'application.
On reproduit exactement les mêmes étapes que pour CardInfos, mais avec beaucoup plus de difficultés...
Voici la liste des problémes rencontrés lors du build :


- se débarasser des deux versions Ext embarquées dans PdmCommon (Ext3 et Ext5 qui n'ont rien à faire là) ainsi que d'un certains nombres d'overrides poubelles situés dans 4 répertoires (_old, _fixforextjs5.0.1.1255, _fixforextjs5.1.1, _fixforextjs6.0.0.415) sous /javascript/lpf/overrides


- Probléme sur l'héritage mis en place dans certaines classes (au nombre de 4), se basant sur une directive "extend: Object". La classe Object n'existe pas, il faut soit la remplacer par Ext.Object ou supprimer cette directive (qui n'a pas l'air de servir à grand chose...)


- Définition d'un alias dans Lectra.PDM.Action.Grid.BaseAction.js qui n'est pas reconnu lors du build. Pas de solution pour le moment, hormis son remplacement avec sa vrai valeur partout ou il est utilisé (4 occurences dans le fichier Lectra.PDM.Action.Grid.EditMode.js).


- Appel de type

		Ext.define('Lectra.PDM.ExplorerEditableGrid', Ext.apply(Lectra.PDM.ExplorerCfg, { ...}));

	  ne marche pas (ex Lectra.PDM.ExplorerGrid.js). Pour le moment ce code est désactivé car pas nécessaire pour notre test. Néanmoins il faudra résoudre ce probléme dans le cas ou on utilise Sencha Cmd.



- un certains nombre d'Overrides posent un probléme (environ 6), ils ne respectent pas la convention de nommage ExtJs. Par exemple :

	    Ext.define('Ext.overrides.Ext.Element', {
			override: 'Ext.dom.Element',

	doit être remplacé par :

	    Ext.define('Override.dom.Element', {
			override: 'Ext.dom.Element',


- Des methodes ou classes indefinies car utilisant ExtJS 3.4

		Ext.define('Lectra.LPF.LockingColumnHeaderGroup', {
			extend: 'Ext.ux.gridLokingColumnHeaderGroup',

- Erreurs de compile sur les tags Velocity.

		LPF.Direct.Router.updateUrl(${#variableName}, '${#formid}');  Ext.direct.Manager.addProvider(${#variableName});

	Cette ligne de code n'a aucun intérêt pour notre test, on la commente.
	Aprés avoir corrigé ces défauts, le Package est généré.

### Générer une page de l'application

Tout comme pour les packages, une page de l'application ou l'application (si single page) doit etre générée à partir du répertoire racine comme suit:

sencha -sdk ./ext generate app page1 ./page1

Cela rajoutera l'arborescence suivante au workspace :

    page1/
       .sencha/               # Sencha-specific files (e.g. configuration)
          app/                # Application-specific content
          sencha.cfg          # Application's configuration file for Sencha Cmd
       app/                   # Sources de l'application
          model/
          store/
          view/
          Application.js
       classic/               # Fichiers pour theme classic (ExtJS 6)
       modern/                # Fichiers pour mobiles (ExtJS 6)
       overrides/             # Override ExtJS
       resources/             # Resources de l'application (images, lang, ...)
       sass/                  # Style de l'appli
       app.js                 #
       classic.json           # Fichier contenant la cross reference "class definition" <---> "nom de fichier".


    build/                    # The folder where build output is placed.
       ...



### Builder l'application
Tout comme pour les packages, l'application doit etre buildé à partir du répertoire racine (single page) ou du repertoire de la page (application multi page), comme suit:

	sencha app build

Au préalable le fichier app.json doit être mis à jour avec la liste des packages nécessaires pour l'application.
Voici la liste des problémes rencontrés lors du build :


- Syntax error sur des noms de variables utilisant des mots clés comme char, int,...


- Sencha cmd verifie la coherence des paramètres passés à une methode, ce qui a permis de détecter des incoherences d'appel de methodes.
 Prenons un exemple, on a la classe

		Ext.define('Lectra.PDM.plugins.Panel.EditionMarker', {
			extend: 'Ext.plugin.Abstract',
		...
			constructor: function(config) {
				Ext.apply(this, config);
				this.callParent(this, config);
			},

	La classe Ext.plugin.Abstract a pour constructeur

	    constructor: function(config) {
	        if (config) {
	            this.pluginConfig = config;
	            this.initConfig(config);
	        }
	    },

	On voit donc une incohérence entre l'appel du constructeur parent

		this.callParent(this, config);

	et la définition de ce constructeur :

		constructor: function(config) {

	En exécutant sencha cmd, on a l'erreur

		[ERR] C2014: callParent expects 0 or 1 argument (null in Lectra.PDM.plugins.Panel.EditionMarker.constructor)

	En effet, il faut écrire

		this.callParent(config);

- On a aussi l'erreur suivante :

		 [ERR] Error: Reference to undeclared variable : $font_icon_font_family at : /home/jacquesbonet/Documents/extjs/workspace7/ext/packages/core/sass/var/list/TreeItem.scss:57
		 [ERR]
		 [ERR] BUILD FAILED
		 [ERR] com.sencha.exceptions.ExBuild: Error: Reference to undeclared variable : $font_icon_font_family at : http://localhost:1841/ext/packages/core/sass/var/list/TreeItem.scss:57
		 [ERR] 	at org.apache.tools.ant.Project.executeSortedTargets(Project.jav
		 [ERR] a:1399)
		 [ERR]
		 [ERR] Total time: 13 seconds
		 [ERR] The following error occurred while executing this line:

	Obligeant à supprimer certains fichiers systèmes (TreeItem.scss) du sdk ExtJS de Sencha.

Une fois corrigée l'ensemble de ces problèmes, l'application se build. De maniére générale le processus de build (package ou build) semble cohérent et la plupart des erreurs remontées cachent un réel probléme qu'il faut corriger

### Modifier l'application
Pour obtenir le test souhaité il faut modifier le code de l'application, à savoir le fichier Main.js pour insérer notre panel "Card Infos" à partir du fichier xml décrivant le screen

	region: 'center',
	xtype: 'tabpanel',
	items:[{
			title: 'Tab 1',
			html: '<h2>Content appropriate for the current navigation.</h2>'
		},
		{
			title: 'Tab 2',
			xtype: 'panel',
			name: 'cardspanel',
			border: 'false',
			header: 'false',
			scrollable: 'true',
			controller: 'specification.list',
			viewModel: 'specification.list',
			items: [{
					xtype: 'specification.header',
					hidden: 'true',
					expandable: 'true'
				},
				{
					xtype: 'hidden',
					name: 'profile-cad-specifications'
				},
				{
					xtype: 'hidden',
					name: 'profile-bom-specifications'
				},
				{
					xtype: 'specification.container',
					name: 'cardslist',
					id: 'cardslist'
				}
			]
		}
	]

ainsi que le fichier MainController.js pour coder l'action sur le bouton qui permet de charger le "Card infos"

	Ext.define('MyApp.view.main.MainController', {
	    extend: 'Ext.app.ViewController',

	    requires: [
	        'Ext.window.MessageBox'
	    ],

	    alias: 'controller.main',

	    onClickButton: function () {
			var product = {
				id: 84024
			}

			var container = Ext.getCmp('cardslist');

			if (container != undefined) {
				container.updateProduct(product);
			}
			else {
				alert(product.id + " bad specifs!");
			}
	    }
	});


### Démarrage de l'application

Le démarrage de l'application se fait en ayant démarrer au préalable une instance de jBoss (port 8080) ainsi qu'un web serveur sur un port libre (autre que 8080) avec la commande DOS:

	http-server -p 8083

L'accés au serveur se fait ensuite ainsi

	http://localhost:8083/


### Problémes lors de l'execution de l'application

Lors de l'execution de l'application nous avons rencontrés les problémes suivants:


- gestion de la session qui n'est pas pris en charge par l'application pour les appels REST(appels cross domain, authentification). Nous avons modifié le code suivant (class Controller.js du package CardInfos) pour résoudre ce probléme dans le cadre de notre test:

		loadSpecifications: function (productId, callback, scope) {
			Ext.Ajax.request({
			  url: Ext.String.format('/styles/{0}/dockets', productId),
			  apiRoot: 'specification',
			  method: 'GET',
			  success: function (response) {
			...

	par

		loadSpecifications: function (productId, callback, scope) {
			Ext.Ajax.request({
			  url: Ext.String.format('http://localhost:8080/specification-docket/rest/styles/{0}/dockets', productId),
			  cors: true,
			  method: 'GET',
			  headers: {
				'X-SessionId': '-340278616533735427'
			  },
			  success: function (response) {




- Problème avec les methodes javascript dans les templates ExtJS.
  Si la methode est defini dans un autre package, le systeme n'arrive pas a résoudre l'adresse de la methode.
Exemple

		tpl: '<tpl for=".">' +
		        '<a href="{[Lectra.PDM.Format.getAbsoluteLinkFromRelativeURl(Lectra.PDM.Format.specPackageLinkUrl(values))]}" target="_parent">{instanceName}</a>' +
		      '</div>' + ...

	Pour notre test, ce code est désactivé. Pour résoudre le probléme nous avons essayé d'utiliser Ext.require ainsi que l'attribut "requires" dans le fichier contenant le template mais cela a échoué dût à des régles de nommage qui ne suivent pas les recommandations Sencha. Si on veux utiliser Sencha cmd, il faudra respecter ces conventions de nommages.


- Certaines instructions ne sont pas interprétées comme export du package, obligeant à les redefinir dans le module principal :

		 Ext.Factory.define
		 Lectra.I18N = (function() {...}

## Elements exportable d'un package Sencha
Pour qu'une classe soit exportable, elle doit etre defini avec l'instruction Ext.define. Les methodes de la classe seront alors exportable.
Pour que des fonctions javascript soient exportable, elles doivent elles aussi etre defini dans une classe defini par Ext.define.
En mode developpement, ces fonctions peuvent etre defini en dehors du Ext.define, mais cela ne marche pas en prod.

Attention : chaque changement de nom de classe ou de nom de fichier neccessitera de rebuilder l'application (meme en mode dev).

	sencha app refresh

## Utilisation d'une librairie tierce dans une application generé par Sencha Cmd.

En incluant le fichier .js de la librairie dans le fichier index.html. Il faudra inclure le fichier avant le fichier bootstrap.

ex :

    <script type="text/javascript" src="/packages/local/currency/src/eve.js"></script>
    <!-- The line below must be kept intact for Sencha Cmd to build your application -->
    <script id="microloader" data-app="15cb5c7a-2a70-40bd-ae4a-e6357d73b764" type="text/javascript" src="bootstrap.js"></script>




## Bilan
Au final l'objectif est atteint! En cinq jours, nous avons réussi à obtenir le résultat attendu : integration des card dans une application Sencha Cmd
Nous avons utilisé 60% du temps pour packager et résoudre les problémes de build, 20% du temps pour adapter le code pour notre test et 20% du temps pour résoudre les problémes d'intégration (cross domain,...).
Nous sommes allé à l'essentiel, le peu de code qui à posé problémes mais qui n'était pas nécessaire pour le test fut désactivé. Cela représente une demi douzaine de classes ou overrides sur l'ensemble du code.
Il n'y a pas eu de bloquage particulier entre ExtJs5 et ExtJs6.

![Image of Yaktocat](http://webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/PDM.png)

![Image of Yaktocat](http://webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/myApp.png)

### Les points positifs
- La modularité est entierement prise en charge par Sencha cmd. Un package correspond à un module.
- La notion de "stack" n'existe plus car le fichier .pkg généré associé au processus de build résout automatiquement ce besoin. Si une erreur survient (il manque une classe par exemple), on ajoute la classe dans le package, on relance la commande de build et le probléme est résolu. C'est l'avantage d'utiliser ce processus de build, qui permet de résoudre ces problémes de dépendences non pas pendant l'execution de l'application mais avant.
- Sencha cmd dans le cadre du démarrage d'un nouveau projet PDM, peut nous permettre de nous passer de LPFExt et des lourdeurs associées tant sur le plan du developpement (mise au point du XML d'un screen de plus en plus compliqué) ainsi que sur les performances (serialization/deserialization à outrance). On pourra se concentrer sur l'essentiel à savoir : javascript/ExtJs/API Rest. Il nous aura fallu trés peu de temps (quelques dizaines de minutes) pour passer de la définition XML du Card Infos à sa version javascript...
- Sencha Cmd impose une rigueur de developpement en particulier sur les nommages des classes, la structuration et l'architecture(MVVM) du projet. Ce respect des normes s'effectue facilement grâce à l'utilisation des outils de génération de code, packaging...

### Les points négatifs
- L'utilisation de Sencha cmd nous lie encore plus avec ExtJs.
- Solution propriétaire. Pas integré nativement dans les nouvelles évolutions du langage Javascript (ES6/ES7) qui comportent des instructions de gestion de packages : mot clef "require" et "export".
- Ne permet l'export que de composants ExtJS, ou defini dans un bloc Ext.define.
- Pas le meme comportement en mode développement et mode production
- Pas de possibilité de réferencer le code d'un autre package. Marche en mode copie pour generer au final un gros app.js contenant tous les .js.
- Possibilité d'incoherence entre les fichiers de build et l'application si modification du nom de package ou nom de classe.
- Les outils Sencha, et ExtJS en particulier sont en perte de vitesse (https://www.google.com/trends/explore#cmpt=q&q=extjs,+angularjs,+react&cat=0-5-31), cela vaut t'il le coup de continuer à investir sur cette bibliothèque?

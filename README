
Intégration modules non ExtJs avec Sencha CMD
==


## Introduction
Le but de cette étude est de déterminer s'il est possible d'intégrer des composants logiciels non ExtJs avec Sencha CMD.
On s'attachera plus particulièrement aux composants construits avec des outils autres que Sencha (Vanilla JS, Angular, React, ...).
Pour une étude sur Sencha Cmd proprement dit, voir le document [http://webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/SenchaCmd.pdf](http://webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/SenchaCmd.pdf)

## Uses cases
On a principalement deux uses cases de developpement :

1. Integration d'un composant tier non développé par nos soins
2. Integration d'un composant développé par nos soins (mais toujours dans une autre techno qu'ExtJS).

On a aussi deux uses cases d'integration:

### Integration par l'intermediaire des packages Sencha

Cela signifie que l'on repackage le composant dans un package Sencha.
Cette solution offre 3 avantages :

- ne pas polluer le fichier index.html de l'application par des imports de fichiers
- l'intégration de composants dans l'application, est faite de facon homogène quelque soit la techno utilisé pour concevoir les composants.
- pouvoir wrapper les composants à integrer comme des composants ExtJS

Elle possède aussi des inconvéniants :

- Obligation d'un repackaging du composant en composant Sencha
- Problème de mise à jour du packaging Sencha Cmd du composant, quand ce composant évolue, sachant que le composant à deja son propre packaging, souvent à base de l'outils bower.

Cette solution n'est réalisable que dans le cas ou l'on developpe nous meme le composant.
Pour un composant tier non développé par nous, il ne semble pas raisonnable d'utiliser cette solution. 

### Integration sans passer par les packages Sencha Cmd
L'intégration du composant dans l'application revient à inclure un ensemble de .css, .js ou .html du composant dans le fichier index.html de l'application.
On lira la documention associé au composant pour connaitre l'ensemble des fichiers à inclure.
Cette solution offre l'avantage de ne pas avoir à refaire un packaging du composant que l'on veut utiliser.

Nous allons étudier ces deux approches dans les chapitres suivants.

## Integration des composants via les packages Sencha

 Recommendations Sencha pour la gestion des packages
> " Each JavaScript source file should contain one Ext.define statement at global scope.
> The name of a source file matches the last segment of the name of the defined type such as the name of the source file containing Ext.define("MyApp.foo.bar.Thing", ... is “Thing.js”.
> All source files are stored in a folder structure that is based on the namespace of the defined type. For example, given Ext.define("MyApp.foo.bar.Thing", ..., the source file is in a path ending with “/foo/bar”.
> Internally, the compiler views source files and classes as basically synonymous. It makes no attempt to split up files to remove classes that are not required. Only complete files are selected and included in the output. This means that if any class in a source file is required, all classes in the file will be included in the output.
> 
> To give the compiler the freedom to select code at the class-level, it is essential to put only one class in each file."

Cela signifie que pour intégrer du code javascript dans un package Sencha, il est obligatoire que chaque fichier javascript contienne une instruction 

    Ext.define( '<nom du module>', {});

en debut de fichier, et ou "nom du module" correspond au namespace du fichier.
 
 
### Conséquence
D'apres ce qui est dit dans le chapitre precedent, l'export de code javascript depuis un package Sencha, neccessitera de modifier les fichiers javascript en y integrant l'instruction 
  
    Ext.define( '<nom du module>', {});
### Politiques d'intégration
Plusieurs politiques d'integrations peuvent etre appliquées suivant la compatibilité du code javascript à integrer :

#### Code à intégrer compatible ExtJS

- Rajout de l'instruction Ext.define avant la phase de build Sencha cmd.
- Rajout des dépendances du composant dans le package Sencha.

Ce rajout peut etre fait soit manuellement soit automatiquement.

#### Code à integrer non compatible ExtJS

Exemples de code non compatible ExtJS :

- Sources ES6
- Fichier .JSX React

Les targets de build à exécuter sont les suivantes pour intégrer un composant dans Sencha Cmd :

- phase de preprocessing afin de generer le code Javascript compatible.
- phase d'insertion de l'instruction Ext.define() sur les fichiers Javascript comportant les fonctions d'export du composant.
- Pour finir, on execute la phase de build Sencha.

Ne pas oublier qu'il faudra aussi prendre en compte les dépendances du composant (bibliotheques, pour les intégrer dans Sencha Cmd).

#### Test d'intégration de code Angular
On va integrer un composant flipcard : angular-flip-card. Ce composant est sous la forme d'un composant bower.

On crée un package Sencha angular-flip-card par la commande

    sencha generate package angular-flip-card

On va dans le répertoire package/locale/angular-flip-card qui vient d'etre crée.
On lance la commande 

    bower install angular-flip-card

pour installer le composant angular-flip-card et ses dépendances dans notre package.
On déplace les sources du composants (pas ses dépendances) dans le répertoire src. Un seul fichier à déplacer : fmpCardDirective.js
On rajoute l'instruction 

    Ext.define( "Angular.FmpCard", {});
    
devant la definition du composant

    angular.module('fmp-card', []).directive("fmpCard", function($timeout, $window) {
    
On modifie la ligne classpath du fichier package.json

    "classpath": "${package.dir}/src,${package.dir}/src/bower_components/angular/angular.js,${package.dir}/src/bower_components/jquery/dist/jquery.js,${package.dir}/${toolkit.name}/src",

pour y rajouter les dépendances Angular et JQuery.

On rebuild le package.

Et on tombe sur l'erreur

    [INF] Mapping http://localhost:1841/~cmd to D:\Users\j.bonet\bin\Sencha\Cmd\6.0.0.202...
    [INF] Mapping http://localhost:1841/ to C:\apps\extjs6\workspace5...
    [INF] Package web server available at http://localhost:1841
    [INF] Writing concatenated output to file C:\apps\extjs6\workspace5\packages\local\cardflip\build\cardflip-debug.js
    [INF] Compressing data with YuiJavascriptCompressor
    [ERR] C2009: YUI Parse Error (il manque un nom aprÞs un opÚrateur '.' =>                             return this.getPromise().catch(f1);) -- unknown-file:5377:59
    [ERR] C2009: YUI Parse Error (il manque un nom aprÞs un opÚrateur '.' =>                             return this.getPromise().finally(f1);) -- unknown-file:5380:61
    [ERR] C2009: YUI Parse Error (Compilation produced 2 syntax errors. => null) -- unknown-file:2
    [ERR]
    [ERR] BUILD FAILED

L'erreur [ERR] C2009: se trouve dans le fichier Angular.js.
Pour débloquer la situation, on enlève ce que l'on a mis dans le classpath pour mettre dans le fichier index.html.

    <script type="text/javascript" src="/packages/locale/cardflip/bower_components/angular/angular.js"></script>
    <script type="text/javascript" src="/packages/locale/cardflip/bower_components/jquery/dist/jquery.js"></script>
    
Coté application :

On rajoute "cardflip" (nom du package) dans le requires du fichier app.json

    "requires": [
        ...
        "cardflip"

pour avoir le code javascript du card flip.
Le problème est qu'Angular n'a pas connaissance du chargement de ce fichier par ExtJS.

On enlève donc le require pour inclure explicitement le fichier dans le index.html

    <script type="text/javascript" src="/packages/local/cardflip/src/fmpCardDirective.js"></script>

Angular a comme ExtJS une phase de bootstrap.
Il faut mettre aussi les instructions :

    <script>
        angular.module('myApp', [])
                .controller('MyController', ['$scope', function ($scope) {
                    $scope.greetMe = 'World';
                }]);
        
        angular.element(document).ready(function() {
            angular.bootstrap(document, ['myApp']);
        });
    </script>

dans le fichier index.html.

De plus ExtJS a sa gestion de module, et Angular aussi.
Il faut etre dans un module Angular pour appeler notre cardflip et l'on ne peut pas avoir dans le meme fichier javascript un Ext.define( ..., {}); et un angular.module( '...').

On ne peut donc pas appeler du code Angular depuis du code ExtJS. Il faut passer par une fonction intermediaire.
La fonction intermediaire appelera une fonction du module Angular pour ensuite créer notre cardflip.

On arrête là. On veut faire de l'integration de composants, la on est dans de la bidouille de code. 

Les composants Angular on beaucoup trop d'adhérence avec leur environnement, obligeant à de nombreuses contraintes pour les faire marcher. 

On peut en conclure, Angular c'est bien, mais seulement si l'on reste dans un monde Angular, un peut comme ExtJS.

## Integration composants sans passer par les packages Sencha
On a vu avec Angular, que l'on a été obligé de bypasser les package Sencha, sans avoir une solution satisfaisante.
Donc cette alternative ne resoud pas notre problème d'intégration.
#### Test d'intégration de code React
La démarche consiste à compiler un fragment de code JS contenant des directives React, et à controler si le code en question s'execute correctement.

Le code JS:

	Ext.define('MyApp.TestReact', {});

	function TestReact() {
		this.commentBox = React.createClass({displayName: 'CommentBox',
			render: function() {
				return (
					React.createElement("div", {className: "commentBox"}, 
						"Hello, world! I am a CommentBox."
					)
				);
			}
		});
	}

	TestReact.prototype.render = function(id) {
		React.render(React.createElement(this.commentBox, null), document.getElementById(id));
	}

Ce code JS est inséré dans un package quelconque qui est buildé puis intégré à l'appli via la démarche habituelle sous Sencha.
L'application doit importer les fichiers nécessaires à React (index.html ou classPath du fichier app.json).
Pour déclencher le rendu dans l'application, ces deux lignes suivantes suffisent et peuvent être placées dans un controller:

	var testReact = new TestReact();
	testReact.render('tabPanel2');

Le principe à l'air de fonctionner avec ce cas simple, à voir avec plus de code à intégrer.


### Integration Polymer dans appli Sencha Cmd.
Polymer est une implémentation Google des WebComponents.
Polymer utilise l'outils Bower pour la gestion des dépendances.

Prenons un composant Polymer : iron-image

Placons nous sous le repertoire racine de l'environnement de dev de notre application, et créons un fichier bower.json.

Mettons y 

	{
	  "name": "PDMPage4",
	  "version": "0.0.0",
	  "dependencies": {
	    "iron-image": "PolymerElements/iron-image#^1.0.0"
	  }
	}
	
Ce fichier contient l'instruction dependencies qui indique quels sont les composants que l'on veut installer sous notre application, dans notre cas le composant iron-image.

Ensuite exécutons la commande 

	bower install

Cette commande va créer un répertoire bower_components a la racine de l'env de dev de notre application et y installer le composant iron-image et ses dépendances.

Mettons dans le fichier index.html de notre application l'instruction

	<link rel="import" href="/PDMPage4/bower_components/iron-image/iron-image.html">

Le fichier iron-image.html est le fichier décrivant notre web component qui a été importé par l'execution de la commande "bower install".

Pour finir, appelons notre webcomponent par la création d'un item de menu dans la side nav de notre application
Par exemple :

	{
	        title: 'Iron-image',
	        iconCls: 'fa-users',
	        bind: {
	            html: '<iron-image class="sized" style="width:100px;height:200px" sizing="cover" src="/PDMPage4/bower_components/iron-image/demo/polymer.svg"></iron-image>'
	        }
	}

On obtient

![Image of Yaktocat](http://j.bonet:AZErty123@webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/webcomponent.png)

Notre image s'est affiché avec une integration très simple.


On ne testera pas l'integration d'un webcomponent dans un package Sencha, car il n'y a aucun interet à le faire à part ajouter de la complexité, et en étant pas sur que cela marche (voir contrainte packaging Sencha).


## Conclusions

### Sencha Cmd
- Le système de packaging de Sencha Cmd apporte un gros plus pour developer des applications ExtJS. Voir le document http://webspace.lectra.com/sites/PMO/PLMV4R4/Shared%20Documents/Modularité%20PDM/SenchaCmd.pdf.

Par contre

- pour integrer des composants tiers dans une application ExtJS, il n'est pas souhaitable de mettre ces composants tiers sous forme de package Sencha. Cela est du aux contraintes inhérantes à ce mode de packaging : problème de build pour certaines partie de code (React, Angular, ES6, ...), mettre des Ext.define dans chaque fichiers du packages, gestion de la cohérence du code dupliqué, ...
- Il est possible d'integrer des composants tiers dans une application généré avec Sencha Cmd sous condition : que ces composants tiers ne dependent pas d'un runtime engendrant une incompatibilité avec ExtJS, comme on a pu le voir avec Angular.
- L'integration est spécifique aux composants développés, enpechant une industrialisation de ceux ci avec une procedure standard d'installation.

Nous pensons que le système de packaging de Sencha Cmd ne repond pas au besoin Lectra d'avoir une offre logiciel en mode cloud et modulaire.


### WebComponent

- Le système de packaging d'un webcomponent assure lui une intégration aisé et homogène dans une application tierce.
- L'installation d'un webcomponent est indépendante de la technologie utilisée pour le développer.
- Ceci permettra de commercialiser ces composants sous forme d'add-on payant.

Les webcomponents sont donc la condition neccessaire pour avoir des composants web interoperables et commercialisable, mais ce n'est pas une condition suffisante.

Mettre sous la forme d'un webcomponent un composant logiciel n'est pas la solution miracle pour assurer  l'interoperabilité des composants.

- Si un composant à besoin d'un runtime et d'un système de bootstrap pour fonctionner (ExtJS par exemple), ce composant à de grande chance de ne pas fonctionner comme webcomponent.
- Afin d'assurer une meilleur opérabilité, les services utilisés par un webcomponent devront eux meme etre developpés sous forme de web components.
Voir l'approche prise par Polymer [https://elements.polymer-project.org/](https://elements.polymer-project.org/) ou l'on classe par famille les webcomponents, avec en particulier les Polymer Core Elements.




